* Functions for using

** Primitive functions
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  P_TOUCH(){
      test -e "./${1}" || touch "./${1}"
  }

  P_GITADD(){
      git add "./${1}"
  }

  P_MKDIR(){
      mkdir -pv -- "./${1}"
  }

  P_CLEAN(){
      rm -vf -- "./${1}"
  }

  P_SET(){
      mkdir -pv -- "$('dirname' -- "./${2}")"
      cp "./${1}" "./${2}"
  }
#+end_src

** Compound functions
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G(){
      P_TOUCH "${1}"
      P_GITADD "${1}"
  }

  S(){
      G "${1}"
      P_SET "${1}" "${2}"
      G "${2}"
  }
#+end_src

** Clean the working file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  P_CLEAN './.git.sh'
#+end_src

** Add this file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'README.org'
#+end_src

* Cargo.toml

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Cargo.toml'
#+end_src

** Actual file
#+begin_src toml :tangle ./Cargo.toml
  [package]
  name = "burn_test"
  version = "0.1.0"
  edition = "2024"

  [dependencies]
  # tch = { version = "0.22.0", path = "../../LaurentMazare/tch-rs", features = ["cpython", "memmap2"] }
  tch = { version = "0.22.0", features = ["cpython", "memmap2"] }
  # aotinductor = "0.1.2"
#+end_src

* build.rs

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build.rs'
#+end_src

** Actual file
#+begin_src rust :tangle ./build.rs
  fn main() {
      let os = std::env::var("CARGO_CFG_TARGET_OS").expect("Unable to get TARGET_OS");
      match os.as_str() {
          "linux" | "windows" => {
              if let Some(lib_path) = std::env::var_os("DEP_TCH_LIBTORCH_LIB") {
                  println!("cargo:rustc-link-arg=-Wl,-rpath={}", lib_path.to_string_lossy());
              }
              println!("cargo:rustc-link-arg=-Wl,--no-as-needed");
              println!("cargo:rustc-link-arg=-ltorch");
          }
          _ => {}
      }
  }
#+end_src

* Python file to produce the model file

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'main.py'
#+end_src

** Actual file
#+begin_src python :shebang #!/usr/bin/env python3 :results output :tangle ./main.py
  import os

  try:
      __file__
  except:
      basepath = "."
  else:
      basepath = os.path.abspath(os.path.dirname(__file__) + "/")
  import sys

  sys.path.append(basepath)
  INPUT_SIZE = 100
  BATCH_SIZE = 4
  import einops
  import timm
  import torch


  def export_to_dynamo(path_file_out):
      with torch.no_grad():
          model = model_wrapper()
          model = torch.compile(
              model=model,
              fullgraph=True,
              dynamic=True,
              backend="inductor",
              mode="max-autotune",
          )
          x = torch.rand(
              (BATCH_SIZE, INPUT_SIZE),
              dtype=torch.float32,
          )
          y = model(x)
          exported_module = torch.export.export(
              mod=model,
              args=(x,),
              strict=True,
          )

          output_path = torch._inductor.aoti_compile_and_package(
              exported_module,
              # [Optional] Specify the generated shared library path. If not specified,
              # the generated artifact is stored in your system temp directory.
              package_path=path_file_out + ".pt2",
          )

          # compiled_model = torch.compile(
          #     model=exported_module.module(),
          #     fullgraph=True,
          #     dynamic=True,
          #     backend="inductor",
          #     mode="max-autotune",
          # )

          jit_module = torch.jit.trace(
              func=exported_module.module(),
              example_inputs=x,
          )
      jit_module.save(path_file_out + ".pt")


  def export_to_onnx(path_file_out):
      model = model_wrapper()
      model = torch.compile(
          model=model,
          fullgraph=True,
          dynamic=True,
          backend="inductor",
          mode="max-autotune",
      )
      x = torch.rand(
          (BATCH_SIZE, INPUT_SIZE),
          dtype=torch.float32,
      )
      y = model(x)
      res = torch.onnx.export(
          slave,
          x,
          path_file_out,
          input_names="x",
          output_names="y",
          opset_version=23,
          dynamo=True,
          external_data=True,
      )


  class model_wrapper(torch.nn.Module):
      def __init__(self):
          super().__init__()
          self.L1 = torch.nn.Linear(
              in_features=INPUT_SIZE,
              out_features=4,
              bias=True,
              dtype=torch.float32,
          )

      def forward(self, x):
          x = self.L1(x)
          return x


  export_to_dynamo(path_file_out="out")
#+end_src

res = torch.jit.trace(
    func = model,
    example_inputs=x,
)

* Script to run

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'run.sh'
#+end_src

** Actual file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./run.sh
  cd "$(dirname -- "${0}")"
  # export LIBTORCH="$(realpath .)/libtorch"
  cargo run
#+end_src

* Container image related functions

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'important_functions.sh'
#+end_src

** Actual script

*** Build container
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./important_functions.sh
  BUILD_CONTAINER () {
      CMD='sudo -A docker'
      which buildah && CMD='buildah'
      ${CMD} build -t "${2}" -f "./${1}"
  }
#+end_src

*** Run container
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./important_functions.sh
  RUN_CONTAINER () {
      CMD='sudo -A docker'
      which podman && CMD='podman'
      ${CMD} run -it --rm -v "$(realpath .):/data" rust_final zsh
  }
#+end_src

* Dockerfile basic

** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_testing.sh'
  G 'Dockerfile_rust_testing'
#+end_src

** Shell script to build
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_testing.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_testing' 'rust_testing'
#+end_src

** Dockerfile

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_testing
  FROM debian:testing-backports
#+end_src

*** ENV stuff
#+begin_src conf :tangle ./Dockerfile_rust_testing
  USER root
  WORKDIR '/root'
  ENV HOME='/root'
  ENV RUSTUP_HOME=/usr/local/rustup
  ENV CARGO_HOME=/usr/local/cargo
  ENV PATH='/usr/local/cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  ENV RUST_VERSION=1.91.0
  ENV DEBIAN_FRONTEND='noninteractive'
#+end_src

*** Installing tools to download rust
#+begin_src conf :tangle ./Dockerfile_rust_testing
  RUN \
      --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
      --mount=target=/var/cache/apt,type=cache,sharing=locked \
      echo 'START apt-get stuff' \
      && apt-get -y update \
      && apt-get install -y \
          'curl' \
          'wget' \
      && echo 'DONE apt-get stuff' ;
#+end_src

*** Installing rust
#+begin_src conf :tangle ./Dockerfile_rust_testing
  RUN set -eux; \
      arch="$(dpkg --print-architecture)"; \
      case "$arch" in \
          'amd64') \
              rustArch='x86_64-unknown-linux-gnu'; \
              rustupSha256='20a06e644b0d9bd2fbdbfd52d42540bdde820ea7df86e92e533c073da0cdd43c'; \
              ;; \
          'armhf') \
              rustArch='armv7-unknown-linux-gnueabihf'; \
              rustupSha256='3b8daab6cc3135f2cd4b12919559e6adaee73a2fbefb830fadf0405c20231d61'; \
              ;; \
          'arm64') \
              rustArch='aarch64-unknown-linux-gnu'; \
              rustupSha256='e3853c5a252fca15252d07cb23a1bdd9377a8c6f3efa01531109281ae47f841c'; \
              ;; \
          'i386') \
              rustArch='i686-unknown-linux-gnu'; \
              rustupSha256='a5db2c4b29d23e9b318b955dd0337d6b52e93933608469085c924e0d05b1df1f'; \
              ;; \
          'ppc64el') \
              rustArch='powerpc64le-unknown-linux-gnu'; \
              rustupSha256='acd89c42b47c93bd4266163a7b05d3f26287d5148413c0d47b2e8a7aa67c9dc0'; \
              ;; \
          's390x') \
              rustArch='s390x-unknown-linux-gnu'; \
              rustupSha256='726b7fd5d8805e73eab4a024a2889f8859d5a44e36041abac0a2436a52d42572'; \
              ;; \
          'riscv64') \
              rustArch='riscv64gc-unknown-linux-gnu'; \
              rustupSha256='09e64cc1b7a3e99adaa15dd2d46a3aad9d44d71041e2a96100d165c98a8fd7a7'; \
              ;; \
          ,*) \
              echo >&2 "unsupported architecture: $arch"; \
              exit 1; \
              ;; \
      esac; \
      url="https://static.rust-lang.org/rustup/archive/1.28.2/${rustArch}/rustup-init"; \
      wget --progress=dot:giga "$url"; \
      echo "${rustupSha256} *rustup-init" | sha256sum -c -; \
      chmod +x rustup-init; \
      ./rustup-init -y --no-modify-path --profile minimal --default-toolchain $RUST_VERSION --default-host ${rustArch}; \
      rm rustup-init; \
      chmod -R a+w $RUSTUP_HOME $CARGO_HOME; \
      rustup --version; \
      cargo --version; \
      rustc --version;
#+end_src

* Dockerfile convenience

** Shell script to build

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_conv.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_conv.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_conv' 'rust_conv'
#+end_src

** Dockerfile

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_conv'
#+end_src

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_conv
  FROM rust_testing
#+end_src

*** Install apt stuff for building
#+begin_src conf :tangle ./Dockerfile_rust_conv
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'build-essential' \
            'git' \
        && echo 'DONE apt-get stuff' ;
#+end_src

*** Build and install rust executables
#+begin_src conf :tangle ./Dockerfile_rust_conv
  RUN cargo install eza
  RUN cargo install starship
#+end_src

* Dockerfile zsh + convenience

** Shell script to build

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_zsh.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_zsh.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_zsh' 'rust_zsh'
#+end_src

** Dockerfile

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_zsh'
#+end_src

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  FROM rust_conv
#+end_src

*** Install apt stuff for building
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'build-essential' \
            'fzf' \
            'git' \
            'zsh' \
        && echo 'DONE apt-get stuff' ;
#+end_src

*** Build and install rust executables
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  RUN git clone --depth 1 --recurse-submodules 'https://github.com/ohmyzsh/ohmyzsh.git' "${HOME}/.oh-my-zsh"
#+end_src

*** zshrc for the image

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'zshrc'
#+end_src

**** Actual script
#+begin_src conf :tangle ./zshrc
  export SHELL=zsh
  export ZSH="$HOME/.oh-my-zsh"
  plugins=(eza fzf git starship vi-mode zsh-interactive-cd)
  source $ZSH/oh-my-zsh.sh
#+end_src

**** Copy the file
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  ADD ./zshrc /root/.zshrc
#+end_src

* Dockerfile libtorch

** Shell script to build

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_libtorch.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_libtorch.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_libtorch' 'rust_libtorch'
#+end_src

** Dockerfile

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_libtorch'
#+end_src

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  FROM rust_zsh
#+end_src

*** Install apt stuff
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'aria2' \
            'python3' \
            'zip' \
        && echo 'DONE apt-get stuff' ;
#+end_src

*** Install apt stuff
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  RUN aria2c -c -x16 -j16 'https://download.pytorch.org/libtorch/cpu/libtorch-shared-with-deps-2.9.0%2Bcpu.zip'
  RUN unzip './libtorch-shared-with-deps-2.9.0+cpu.zip'
  RUN rm -vf -- './libtorch-shared-with-deps-2.9.0+cpu.zip'
  ENV LIBTORCH="/usr/"
  RUN \
      echo 'Install libtorch' \
      && cd libtorch \
      && cd lib \
      && ls | sed 's@^@(cp -vapf -- "@g;s@$@" "/usr/lib/");@g' | sh \
      && cd .. \
      && cd include \
      && ls | sed 's@^@(cp -vapf -- "@g;s@$@" "/usr/include/");@g' | sh \
      && cd .. \
      && cd share/cmake \
      && ls | sed 's@^@(cp -vapf -- "@g;s@$@" "/usr/share/cmake");@g' | sh \
      && cd ../.. \
      && cd .. \
      && echo 'Done Install libtorch' ;
#+end_src

* Dockerfile finalizing

** Shell script to build

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_final.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_final.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_final' 'rust_final'
#+end_src

** Dockerfile

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_final'
#+end_src

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_final
  FROM rust_libtorch
#+end_src

*** Install rust analyzer
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN \
      echo 'Start rust analyzer install' \
          && curl -L 'https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz' \
          | gunzip -c - \
          > '/usr/local/bin/rust-analyzer' \
          && chmod +x '/usr/local/bin/rust-analyzer' \
      && echo 'Done rust analyzer install' ;
#+end_src

*** Installing helix
#+begin_src conf :tangle ./Dockerfile_rust_final
  USER root
  RUN aria2c -c -x16 -j16 'https://github.com/helix-editor/helix/releases/download/25.07.1/helix-25.07.1-x86_64-linux.tar.xz'
  RUN tar -xf ./helix-25.07.1-x86_64-linux.tar.xz
  RUN \
      echo 'Start installing helix' \
          && rm -vf -- 'helix-25.07.1-x86_64-linux.tar.xz' \
          && cd './helix-25.07.1-x86_64-linux/' \
          && mv hx /usr/local/bin \
          && mv runtime /usr/local/bin \
          && mv contrib/completion/hx.bash /usr/share/bash-completion/completions/hx \
          && mv ./contrib/completion/hx.zsh /usr/share/zsh/vendor-completions/_hx \
          && chown 'root:root' '/usr/share/zsh/vendor-completions/_hx' \
          && mv ./contrib/completion/hx.fish /usr/share/fish/completions/hx.fish \
          && cd .. \
          && rm -rf -- './helix-25.07.1-x86_64-linux/' \
      && echo 'Done installing helix' ;
#+end_src

*** Configuring helix

**** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'config.toml'
#+end_src

**** The actual config file
#+begin_src conf :tangle ./config.toml
  theme = "modus_vivendi"

  [editor]
  true-color = true
#+end_src

**** Copy the file
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN mkdir -pv -- '/root/.config/helix'
  ADD ./config.toml '/root/.config/helix/config.toml'
#+end_src

*** Add rustfmt
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN rustup component add rustfmt
#+end_src

*** Install apt stuff for editing
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'neovim' \
            'python3' \
            'python3-dev' \
            'python3-pip' \
            'python3-venv' \
        && echo 'DONE apt-get stuff' ;
#+end_src

* Script to run

** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'podman_run.sh'
#+end_src

** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./podman_run.sh
  . './important_functions.sh'
  RUN_CONTAINER
#+end_src

* Main rust code

** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  S 'src,main.rs' 'src/main.rs'
#+end_src

** Actual code
#+begin_src rust :tangle ./src,main.rs
  use tch::CModule;
  use tch::Device;
  use tch::Kind;
  use tch::Tensor;

  fn main() {

      let t = Tensor::from_slice(&[3, 1, 4, 1, 5]);
      let t = t * 2;
      t.print();

      let device = Device::cuda_if_available();
      let model = CModule::load_on_device("./out.pt", device).unwrap();

      println!("Model loaded successfully and moved to {:?}", device);

      println!("asd")
  }
#+end_src

    let input_tensor = Tensor::rand(&[1, 10], (Kind::Float, device));
    
    // 4. Run Inference
    // `forward_ts` takes a slice of input Tensors and returns an IValue, 
    // which we then expect to be a single Tensor (Tensors are the common IValue output).
    println!("Running inference...");
    let output_ivalue = model
        .forward_ts(&[input_tensor])
        .context("Inference failed")?;

    // 5. Extract and print the output
    let output_tensor = output_ivalue.try_into_tensor()?;
    
    println!("Inference result:");
    println!("  Shape: {:?}", output_tensor.size());
    
    // Convert the output tensor to a Rust Vec on CPU for easy viewing
    let output_data: Vec<f32> = output_tensor.to_device(Device::Cpu).try_into()?;
    println!("  Data: {:?}", output_data);

* Try inference in c++
#+begin_src c++ :tangle ./main.cpp
  #include <iostream>
  #include <vector>

  #include <torch/csrc/inductor/aoti_package/model_package_loader.h>
  #include <torch/torch.h>

  int main() {
    c10::InferenceMode mode;

    torch::inductor::AOTIModelPackageLoader loader("out.pt2");
    std::vector<torch::Tensor> inputs = {torch::randn({4, 100}, at::kCPU)};
    std::vector<torch::Tensor> outputs = loader.run(inputs);
    std::cout << "Result from the first inference:" << std::endl;
    std::cout << outputs[0] << std::endl;

    return 0;
  }
#+end_src

* COMMENT Work space
#+begin_src emacs-lisp :results silent
  (save-buffer)
  (org-babel-tangle)
  (async-shell-command "
      './.git.sh'
  " "log" "err")
#+end_src

