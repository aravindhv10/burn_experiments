* Functions for using

** Primitive functions
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  P_TOUCH(){
      test -e "./${1}" || touch "./${1}"
  }

  P_GITADD(){
      git add "./${1}"
  }

  P_MKDIR(){
      mkdir -pv -- "./${1}"
  }

  P_CLEAN(){
      rm -vf -- "./${1}"
  }
#+end_src

** Compound functions
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G(){
      P_TOUCH "${1}"
      P_GITADD "${1}"
  }
#+end_src

** Clean the working file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  P_CLEAN './.git.sh'
#+end_src

** Add this file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'README.org'
#+end_src

* Cargo.toml

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Cargo.toml'
#+end_src

** Actual file
#+begin_src toml :tangle ./Cargo.toml
  [package]
  name = "burn_test"
  version = "0.1.0"
  edition = "2024"

  [dependencies]
  # tch = { version = "0.22.0", path = "../../LaurentMazare/tch-rs", features = ["cpython", "memmap2"] }
  tch = { version = "0.22.0", features = ["cpython", "memmap2"] }
#+end_src

* build.rs

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build.rs'
#+end_src

** Actual file
#+begin_src rust :tangle ./build.rs
  fn main() {
      let os = std::env::var("CARGO_CFG_TARGET_OS").expect("Unable to get TARGET_OS");
      match os.as_str() {
          "linux" | "windows" => {
              if let Some(lib_path) = std::env::var_os("DEP_TCH_LIBTORCH_LIB") {
                  println!("cargo:rustc-link-arg=-Wl,-rpath={}", lib_path.to_string_lossy());
              }
              println!("cargo:rustc-link-arg=-Wl,--no-as-needed");
              println!("cargo:rustc-link-arg=-ltorch");
          }
          _ => {}
      }
  }
#+end_src

* Python file to produce the model file

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'main.py'
#+end_src

** Actual file
#+begin_src python :shebang #!/usr/bin/env python3 :results output :tangle ./main.py
  import os

  try:
      __file__
  except:
      basepath = "."
  else:
      basepath = os.path.abspath(os.path.dirname(__file__) + "/")
  import sys

  sys.path.append(basepath)
  INPUT_SIZE = 100
  BATCH_SIZE = 4
  import einops
  import timm
  import torch


  def export_to_dynamo(path_file_out):
      model = model_wrapper()
      model = torch.compile(
          model=model,
          fullgraph=True,
          dynamic=True,
          backend="inductor",
          mode="max-autotune",
      )
      x = torch.rand(
          (BATCH_SIZE, INPUT_SIZE),
          dtype=torch.float32,
      )
      y = model(x)
      exported_module = torch.export.export(
          mod=model,
          args=(x,),
          strict=True,
      )
      torch.export.save(exported_module, path_file_out)


  def export_to_onnx(path_file_out):
      model = model_wrapper()
      model = torch.compile(
          model=model,
          fullgraph=True,
          dynamic=True,
          backend="inductor",
          mode="max-autotune",
      )
      x = torch.rand(
          (BATCH_SIZE, INPUT_SIZE),
          dtype=torch.float32,
      )
      y = model(x)
      res = torch.onnx.export(
          slave,
          x,
          path_file_out,
          input_names="x",
          output_names="y",
          opset_version=23,
          dynamo=True,
          external_data=True,
      )


  class model_wrapper(torch.nn.Module):
      def __init__(self):
          super().__init__()
          self.L1 = torch.nn.Linear(
              in_features=INPUT_SIZE,
              out_features=4,
              bias=True,
              dtype=torch.float32,
          )

      def forward(self, x):
          x = self.L1(x)
          return x


  export_to_dynamo(path_file_out="out.pt2")
#+end_src

* Script to run

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'run.sh'
#+end_src

** Actual file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./run.sh
  cd "$(dirname -- "${0}")"
  export LIBTORCH="$(realpath .)/libtorch"
  cargo run
#+end_src

* Container image related functions

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'important_functions.sh'
#+end_src

** Actual script

*** Build container
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./important_functions.sh
  BUILD_CONTAINER () {
      CMD='sudo -A docker'
      which buildah && CMD='buildah'
      ${CMD} build -t "${2}" -f "./${1}"
  }
#+end_src

*** Run container
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./important_functions.sh
  RUN_CONTAINER () {
      CMD='sudo -A docker'
      which podman && CMD='podman'
      ${CMD} run -it --rm -v "$(realpath .):/data" rust_final zsh
  }
#+end_src

* Dockerfile basic

** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_testing.sh'
  G 'Dockerfile_rust_testing'
#+end_src

** Shell script to build
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_testing.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_testing' 'rust_testing'
#+end_src

** Dockerfile

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_testing
  FROM debian:testing-backports
#+end_src

*** ENV stuff
#+begin_src conf :tangle ./Dockerfile_rust_testing
  USER root
  WORKDIR '/root'
  ENV HOME='/root'
  ENV RUSTUP_HOME=/usr/local/rustup
  ENV CARGO_HOME=/usr/local/cargo
  ENV PATH='/usr/local/cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  ENV RUST_VERSION=1.91.0
  ENV DEBIAN_FRONTEND='noninteractive'
#+end_src

*** Installing tools to download rust
#+begin_src conf :tangle ./Dockerfile_rust_testing
  RUN \
      --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
      --mount=target=/var/cache/apt,type=cache,sharing=locked \
      echo 'START apt-get stuff' \
      && apt-get -y update \
      && apt-get install -y \
          'curl' \
          'wget' \
      && echo 'DONE apt-get stuff' ;
#+end_src

*** Installing rust
#+begin_src conf :tangle ./Dockerfile_rust_testing
  RUN set -eux; \
      arch="$(dpkg --print-architecture)"; \
      case "$arch" in \
          'amd64') \
              rustArch='x86_64-unknown-linux-gnu'; \
              rustupSha256='20a06e644b0d9bd2fbdbfd52d42540bdde820ea7df86e92e533c073da0cdd43c'; \
              ;; \
          'armhf') \
              rustArch='armv7-unknown-linux-gnueabihf'; \
              rustupSha256='3b8daab6cc3135f2cd4b12919559e6adaee73a2fbefb830fadf0405c20231d61'; \
              ;; \
          'arm64') \
              rustArch='aarch64-unknown-linux-gnu'; \
              rustupSha256='e3853c5a252fca15252d07cb23a1bdd9377a8c6f3efa01531109281ae47f841c'; \
              ;; \
          'i386') \
              rustArch='i686-unknown-linux-gnu'; \
              rustupSha256='a5db2c4b29d23e9b318b955dd0337d6b52e93933608469085c924e0d05b1df1f'; \
              ;; \
          'ppc64el') \
              rustArch='powerpc64le-unknown-linux-gnu'; \
              rustupSha256='acd89c42b47c93bd4266163a7b05d3f26287d5148413c0d47b2e8a7aa67c9dc0'; \
              ;; \
          's390x') \
              rustArch='s390x-unknown-linux-gnu'; \
              rustupSha256='726b7fd5d8805e73eab4a024a2889f8859d5a44e36041abac0a2436a52d42572'; \
              ;; \
          'riscv64') \
              rustArch='riscv64gc-unknown-linux-gnu'; \
              rustupSha256='09e64cc1b7a3e99adaa15dd2d46a3aad9d44d71041e2a96100d165c98a8fd7a7'; \
              ;; \
          ,*) \
              echo >&2 "unsupported architecture: $arch"; \
              exit 1; \
              ;; \
      esac; \
      url="https://static.rust-lang.org/rustup/archive/1.28.2/${rustArch}/rustup-init"; \
      wget --progress=dot:giga "$url"; \
      echo "${rustupSha256} *rustup-init" | sha256sum -c -; \
      chmod +x rustup-init; \
      ./rustup-init -y --no-modify-path --profile minimal --default-toolchain $RUST_VERSION --default-host ${rustArch}; \
      rm rustup-init; \
      chmod -R a+w $RUSTUP_HOME $CARGO_HOME; \
      rustup --version; \
      cargo --version; \
      rustc --version;
#+end_src

* Dockerfile convenience

** Shell script to build

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_conv.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_conv.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_conv' 'rust_conv'
#+end_src

** Dockerfile

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_conv'
#+end_src

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_conv
  FROM rust_testing
#+end_src

*** Install apt stuff for building
#+begin_src conf :tangle ./Dockerfile_rust_conv
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'build-essential' \
            'git' \
        && echo 'DONE apt-get stuff' ;
#+end_src

*** Build and install rust executables
#+begin_src conf :tangle ./Dockerfile_rust_conv
  RUN cargo install eza
  RUN cargo install starship
#+end_src

* Dockerfile zsh + convenience

** Shell script to build

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_zsh.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_zsh.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_zsh' 'rust_zsh'
#+end_src

** Dockerfile

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_zsh'
#+end_src

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  FROM rust_conv
#+end_src

*** Install apt stuff for building
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'build-essential' \
            'fzf' \
            'git' \
            'zsh' \
        && echo 'DONE apt-get stuff' ;
#+end_src

*** Build and install rust executables
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  RUN git clone --depth 1 --recurse-submodules 'https://github.com/ohmyzsh/ohmyzsh.git' "${HOME}/.oh-my-zsh"
#+end_src

*** zshrc for the image

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'zshrc'
#+end_src

**** Actual script
#+begin_src conf :tangle ./zshrc
  export SHELL=zsh
  export ZSH="$HOME/.oh-my-zsh"
  plugins=(eza fzf git starship vi-mode zsh-interactive-cd)
  source $ZSH/oh-my-zsh.sh
#+end_src

**** Copy the file
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  ADD ./zshrc /root/.zshrc
#+end_src

* Dockerfile libtorch

** Shell script to build

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_libtorch.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_libtorch.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_libtorch' 'rust_libtorch'
#+end_src

** Dockerfile

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_libtorch'
#+end_src

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  FROM rust_zsh
#+end_src

*** Install apt stuff
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'aria2' \
            'python3' \
            'zip' \
        && echo 'DONE apt-get stuff' ;
#+end_src

*** Install apt stuff
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  RUN aria2c -c -x16 -j16 'https://download.pytorch.org/libtorch/cpu/libtorch-shared-with-deps-2.9.0%2Bcpu.zip'
  RUN unzip './libtorch-shared-with-deps-2.9.0+cpu.zip'
#+end_src

* Dockerfile finalizing

** Shell script to build

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_final.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_final.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_final' 'rust_final'
#+end_src

** Dockerfile

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_final'
#+end_src

*** Base image
#+begin_src conf :tangle ./Dockerfile_rust_final
  FROM rust_libtorch
  ENV LIBTORCH="/root/libtorch"
  RUN rm -vf -- '/root/libtorch-shared-with-deps-2.9.0+cpu.zip'
#+end_src

*** Install rust analyzer
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN \
      echo 'Start rust analyzer install' \
          && curl -L 'https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz' \
          | gunzip -c - \
          > '/usr/local/bin/rust-analyzer' \
          && chmod +x '/usr/local/bin/rust-analyzer' \
      && echo 'Done rust analyzer install' ;
#+end_src

*** Installing helix
#+begin_src conf :tangle ./Dockerfile_rust_final
  USER root
  RUN aria2c -c -x16 -j16 'https://github.com/helix-editor/helix/releases/download/25.07.1/helix-25.07.1-x86_64-linux.tar.xz'
  RUN tar -xf ./helix-25.07.1-x86_64-linux.tar.xz
  RUN \
      echo 'Start installing helix' \
          && cd ./helix-25.07.1-x86_64-linux/ \
          && mv hx /usr/local/bin \
          && mv runtime /usr/local/bin \
          && mv contrib/completion/hx.bash /usr/share/bash-completion/completions/hx \
          && mv ./contrib/completion/hx.zsh /usr/share/zsh/vendor-completions/_hx \
          && chown 'root:root' '/usr/share/zsh/vendor-completions/_hx' \
          && mv ./contrib/completion/hx.fish /usr/share/fish/completions/hx.fish \
      && echo 'Done installing helix' ;
#+end_src


*** Install apt stuff for editing
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'neovim' \
        && echo 'DONE apt-get stuff' ;
#+end_src

* Script to run

** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'podman_run.sh'
#+end_src

** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./podman_run.sh
  . './important_functions.sh'
  RUN_CONTAINER
#+end_src

* COMMENT Work space
#+begin_src emacs-lisp :results silent
  (save-buffer)
  (org-babel-tangle)
  (async-shell-command "
      './.git.sh'
  " "log" "err")
#+end_src
