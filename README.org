* Functions for using

** Primitive functions
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  P_TOUCH(){
      test -e "./${1}" || touch "./${1}"
  }

  P_GITADD(){
      git add "./${1}"
  }

  P_MKDIR(){
      mkdir -pv -- "./${1}"
  }

  P_CLEAN(){
      rm -vf -- "./${1}"
  }

  P_SET(){
      mkdir -pv -- "$('dirname' -- "./${2}")"
      cp "./${1}" "./${2}"
  }
#+end_src

** Compound functions
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G(){
      P_TOUCH "${1}"
      P_GITADD "${1}"
  }

  S(){
      G "${1}"
      P_SET "${1}" "${2}"
      G "${2}"
  }
#+end_src

** Clean the working file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  P_CLEAN './.git.sh'
#+end_src

** Add this file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'README.org'
#+end_src

* Container image related functions

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'important_functions.sh'
#+end_src

** Actual script

*** Build container
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./important_functions.sh
  BUILD_CONTAINER () {
      CMD='sudo -A docker'
      which buildah && CMD='buildah'
      ${CMD} build -t "${2}" -f "./${1}"
  }
#+end_src

*** Run container
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./important_functions.sh
  RUN_CONTAINER () {
      CMD='sudo -A docker'
      which podman && CMD='podman'
      ${CMD} run -it --rm -v "$(realpath .):/data" rust_final zsh
  }
#+end_src

* All docker image building files

** Dockerfile basic

*** Shell script to build

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_testing.sh'
#+end_src

**** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_testing.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_testing' 'rust_testing'
#+end_src

*** Dockerfile

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_testing'
#+end_src

**** Base image
#+begin_src conf :tangle ./Dockerfile_rust_testing
  FROM debian:testing-backports
#+end_src

**** ENV stuff
#+begin_src conf :tangle ./Dockerfile_rust_testing
  USER root
  WORKDIR '/root'
  ENV HOME='/root'
  ENV RUSTUP_HOME=/usr/local/rustup
  ENV CARGO_HOME=/usr/local/cargo
  ENV PATH='/usr/local/cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  ENV RUST_VERSION=1.91.0
  ENV DEBIAN_FRONTEND='noninteractive'
#+end_src

**** Installing tools to download rust
#+begin_src conf :tangle ./Dockerfile_rust_testing
  RUN \
      --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
      --mount=target=/var/cache/apt,type=cache,sharing=locked \
      echo 'START apt-get stuff' \
      && apt-get -y update \
      && apt-get install -y \
          'curl' \
          'wget' \
      && echo 'DONE apt-get stuff' ;
#+end_src

**** Installing rust
#+begin_src conf :tangle ./Dockerfile_rust_testing
  RUN set -eux; \
      arch="$(dpkg --print-architecture)"; \
      case "$arch" in \
          'amd64') \
              rustArch='x86_64-unknown-linux-gnu'; \
              rustupSha256='20a06e644b0d9bd2fbdbfd52d42540bdde820ea7df86e92e533c073da0cdd43c'; \
              ;; \
          'armhf') \
              rustArch='armv7-unknown-linux-gnueabihf'; \
              rustupSha256='3b8daab6cc3135f2cd4b12919559e6adaee73a2fbefb830fadf0405c20231d61'; \
              ;; \
          'arm64') \
              rustArch='aarch64-unknown-linux-gnu'; \
              rustupSha256='e3853c5a252fca15252d07cb23a1bdd9377a8c6f3efa01531109281ae47f841c'; \
              ;; \
          'i386') \
              rustArch='i686-unknown-linux-gnu'; \
              rustupSha256='a5db2c4b29d23e9b318b955dd0337d6b52e93933608469085c924e0d05b1df1f'; \
              ;; \
          'ppc64el') \
              rustArch='powerpc64le-unknown-linux-gnu'; \
              rustupSha256='acd89c42b47c93bd4266163a7b05d3f26287d5148413c0d47b2e8a7aa67c9dc0'; \
              ;; \
          's390x') \
              rustArch='s390x-unknown-linux-gnu'; \
              rustupSha256='726b7fd5d8805e73eab4a024a2889f8859d5a44e36041abac0a2436a52d42572'; \
              ;; \
          'riscv64') \
              rustArch='riscv64gc-unknown-linux-gnu'; \
              rustupSha256='09e64cc1b7a3e99adaa15dd2d46a3aad9d44d71041e2a96100d165c98a8fd7a7'; \
              ;; \
          ,*) \
              echo >&2 "unsupported architecture: $arch"; \
              exit 1; \
              ;; \
      esac; \
      url="https://static.rust-lang.org/rustup/archive/1.28.2/${rustArch}/rustup-init"; \
      wget --progress=dot:giga "$url"; \
      echo "${rustupSha256} *rustup-init" | sha256sum -c -; \
      chmod +x rustup-init; \
      ./rustup-init -y --no-modify-path --profile minimal --default-toolchain $RUST_VERSION --default-host ${rustArch}; \
      rm rustup-init; \
      chmod -R a+w $RUSTUP_HOME $CARGO_HOME; \
      rustup --version; \
      cargo --version; \
      rustc --version;
#+end_src

** Dockerfile convenience

*** Shell script to build

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_conv.sh'
#+end_src

**** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_conv.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_conv' 'rust_conv'
#+end_src

*** Dockerfile

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_conv'
#+end_src

**** Base image
#+begin_src conf :tangle ./Dockerfile_rust_conv
  FROM rust_testing
#+end_src

**** Install apt stuff for building
#+begin_src conf :tangle ./Dockerfile_rust_conv
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'build-essential' \
            'git' \
        && echo 'DONE apt-get stuff' ;
#+end_src

**** Build and install rust executables
#+begin_src conf :tangle ./Dockerfile_rust_conv
  RUN cargo install eza
  RUN cargo install starship
#+end_src

** Dockerfile zsh + convenience

*** Shell script to build

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_zsh.sh'
#+end_src

**** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_zsh.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_zsh' 'rust_zsh'
#+end_src

*** Dockerfile

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_zsh'
#+end_src

**** Base image
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  FROM rust_conv
#+end_src

**** Install apt stuff for building
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'build-essential' \
            'fzf' \
            'git' \
            'zsh' \
        && echo 'DONE apt-get stuff' ;
#+end_src

**** Build and install rust executables
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  RUN git clone --depth 1 --recurse-submodules 'https://github.com/ohmyzsh/ohmyzsh.git' "${HOME}/.oh-my-zsh"
#+end_src

**** zshrc for the image

***** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'zshrc'
#+end_src

***** Actual script
#+begin_src conf :tangle ./zshrc
  export SHELL=zsh
  export ZSH="$HOME/.oh-my-zsh"
  plugins=(eza fzf git starship vi-mode zsh-interactive-cd)
  source $ZSH/oh-my-zsh.sh
#+end_src

***** Copy the file
#+begin_src conf :tangle ./Dockerfile_rust_zsh
  ADD ./zshrc /root/.zshrc
#+end_src

** Dockerfile libtorch

*** Shell script to build

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_libtorch.sh'
#+end_src

**** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_libtorch.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_libtorch' 'rust_libtorch'
#+end_src

*** Dockerfile

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_libtorch'
#+end_src

**** Base image
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  FROM rust_zsh
#+end_src

**** Install apt stuff
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'aria2' \
            'python3' \
            'zip' \
        && echo 'DONE apt-get stuff' ;
#+end_src

**** Install libtorch
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  RUN aria2c -c -x16 -j16 'https://download.pytorch.org/libtorch/cpu/libtorch-shared-with-deps-2.9.0%2Bcpu.zip'
  RUN unzip './libtorch-shared-with-deps-2.9.0+cpu.zip'
  RUN rm -vf -- './libtorch-shared-with-deps-2.9.0+cpu.zip'
  ENV LIBTORCH="/usr/"
  RUN \
      echo 'Install libtorch' \
      && cd libtorch \
      && cd lib \
      && ls | sed 's@^@(cp -vapf -- "@g;s@$@" "/usr/lib/");@g' | sh \
      && cd .. \
      && cd include \
      && ls | sed 's@^@(cp -vapf -- "@g;s@$@" "/usr/include/");@g' | sh \
      && cd .. \
      && cd share/cmake \
      && ls | sed 's@^@(cp -vapf -- "@g;s@$@" "/usr/share/cmake");@g' | sh \
      && cd ../.. \
      && cd .. \
      && echo 'Done Install libtorch' ;
#+end_src

**** Install bindgen
#+begin_src conf :tangle ./Dockerfile_rust_libtorch
  RUN cargo install bindgen-cli
#+end_src

** Dockerfile finalizing

*** Shell script to build

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build_rust_final.sh'
#+end_src

**** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./build_rust_final.sh
  . './important_functions.sh'
  BUILD_CONTAINER 'Dockerfile_rust_final' 'rust_final'
#+end_src

*** Dockerfile

**** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Dockerfile_rust_final'
#+end_src

**** Base image
#+begin_src conf :tangle ./Dockerfile_rust_final
  FROM rust_libtorch
#+end_src

**** Install rust analyzer
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN \
      echo 'Start rust analyzer install' \
          && curl -L 'https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz' \
          | gunzip -c - \
          > '/usr/local/bin/rust-analyzer' \
          && chmod +x '/usr/local/bin/rust-analyzer' \
      && echo 'Done rust analyzer install' ;
#+end_src

**** Installing helix
#+begin_src conf :tangle ./Dockerfile_rust_final
  USER root
  RUN aria2c -c -x16 -j16 'https://github.com/helix-editor/helix/releases/download/25.07.1/helix-25.07.1-x86_64-linux.tar.xz'
  RUN tar -xf ./helix-25.07.1-x86_64-linux.tar.xz
  RUN \
      echo 'Start installing helix' \
          && rm -vf -- 'helix-25.07.1-x86_64-linux.tar.xz' \
          && cd './helix-25.07.1-x86_64-linux/' \
          && mv hx /usr/local/bin \
          && mv runtime /usr/local/bin \
          && mv contrib/completion/hx.bash /usr/share/bash-completion/completions/hx \
          && mv ./contrib/completion/hx.zsh /usr/share/zsh/vendor-completions/_hx \
          && chown 'root:root' '/usr/share/zsh/vendor-completions/_hx' \
          && mv ./contrib/completion/hx.fish /usr/share/fish/completions/hx.fish \
          && cd .. \
          && rm -rf -- './helix-25.07.1-x86_64-linux/' \
      && echo 'Done installing helix' ;
#+end_src

**** Configuring helix

***** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'config.toml'
#+end_src

***** The actual config file
#+begin_src conf :tangle ./config.toml
  theme = "modus_vivendi"

  [editor]
  true-color = true
#+end_src

***** Copy the file
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN mkdir -pv -- '/root/.config/helix'
  ADD ./config.toml '/root/.config/helix/config.toml'
#+end_src

**** Add rustfmt
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN rustup component add rustfmt
#+end_src

**** Install apt stuff for editing
#+begin_src conf :tangle ./Dockerfile_rust_final
  RUN \
        --mount=target=/var/lib/apt/lists,type=cache,sharing=locked \
        --mount=target=/var/cache/apt,type=cache,sharing=locked \
        echo 'START apt-get stuff' \
        && apt-get -y update \
        && apt-get install -y \
            'cmake' \
            'libclang-dev' \
            'neovim' \
            'python3' \
            'python3-dev' \
            'python3-pip' \
            'python3-venv' \
        && echo 'DONE apt-get stuff' ;
#+end_src

** Script to run the final image

*** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'podman_run.sh'
#+end_src

*** Actual script
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./podman_run.sh
  . './important_functions.sh'
  RUN_CONTAINER
#+end_src

* Python file to produce the model file

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'main.py'
#+end_src

** Actual file
#+begin_src python :shebang #!/usr/bin/env python3 :results output :tangle ./main.py
  import os

  try:
      __file__
  except:
      basepath = "."
  else:
      basepath = os.path.abspath(os.path.dirname(__file__) + "/")
  import sys

  sys.path.append(basepath)
  INPUT_SIZE = 100
  BATCH_SIZE = 4
  import einops
  import timm
  import torch
  from torch.export.dynamic_shapes import Dim


  def export_to_dynamo(path_file_out):
      with torch.no_grad():
          model = model_wrapper()
          model = torch.compile(
              model=model,
              fullgraph=True,
              dynamic=True,
              backend="inductor",
              mode="max-autotune",
          )
          x = torch.rand(
              (BATCH_SIZE, INPUT_SIZE),
              dtype=torch.float32,
          )
          y = model(x)

          dynamic_shapes = {
              "x": (Dim.DYNAMIC, Dim.STATIC),
          }
          exported_module = torch.export.export(
              model._orig_mod,
              (x,),
              dynamic_shapes=dynamic_shapes,
              # strict=True,
              # dynamic_shapes=dynamic_shapes,
          )

          output_path = torch._inductor.aoti_compile_and_package(
              exported_module,
              # [Optional] Specify the generated shared library path. If not specified,
              # the generated artifact is stored in your system temp directory.
              package_path=path_file_out + ".pt2",
          )

          # compiled_model = torch.compile(
          #     model=exported_module.module(),
          #     fullgraph=True,
          #     dynamic=True,
          #     backend="inductor",
          #     mode="max-autotune",
          # )

          jit_module = torch.jit.trace(
              func=exported_module.module(),
              example_inputs=x,
          )
      jit_module.save(path_file_out + ".pt")


  def export_to_onnx(path_file_out):
      model = model_wrapper()
      model = torch.compile(
          model=model,
          fullgraph=True,
          dynamic=True,
          backend="inductor",
          mode="max-autotune",
      )
      x = torch.rand(
          (BATCH_SIZE, INPUT_SIZE),
          dtype=torch.float32,
      )
      y = model(x)
      res = torch.onnx.export(
          slave,
          x,
          path_file_out,
          input_names="x",
          output_names="y",
          opset_version=23,
          dynamo=True,
          external_data=True,
      )


  class model_wrapper(torch.nn.Module):
      def __init__(self):
          super().__init__()
          self.L1 = torch.nn.Linear(
              in_features=INPUT_SIZE,
              out_features=4,
              bias=True,
              dtype=torch.float32,
          )

      def forward(
          self,
          x: torch.Tensor,
      ):
          x = self.L1(x)
          return x


  export_to_dynamo(path_file_out="out")
#+end_src

* C++ program

** Add file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  S 'src,main.cpp' 'src/main.cpp'
  S 'src,main.hpp' 'src/main.hpp'
  G 'compile_g++.sh'
#+end_src

** Actual file

*** COMMENT Testing junk
#+begin_src c++ :tangle ./src,main.cpp
  #include "stdio.h"
  #include <iostream>
  #include <vector>

  #include <torch/torch.h>
  #include <torch/csrc/inductor/aoti_package/model_package_loader.h>
  extern "C" {
  int torchmain() {
    printf("Working...\n");

      return 0;
  }
  }
#+end_src

*** Torch
#+begin_src c++ :tangle ./src,main.cpp
  #include <iostream>
  #include <vector>

  #include <torch/torch.h>
  #include <torch/csrc/inductor/aoti_package/model_package_loader.h>

  extern "C" {
  int torchmain() {
      c10::InferenceMode mode;

      torch::inductor::AOTIModelPackageLoader loader("out.pt2");
      std::vector<torch::Tensor> inputs = {torch::randn({8, 100}, at::kCPU)};
      std::vector<torch::Tensor> outputs = loader.run(inputs);
      std::cout << "Result from the first inference:"<< std::endl;
      std::cout << outputs[0] << std::endl;

      return 0;
  }
  }
#+end_src

** Header file
#+begin_src c++ :tangle ./src,main.hpp
  extern "C" {
    int torchmain();
  }
#+end_src

** tmp testing file
#+begin_src c++ :tangle ./tmp.cpp
  extern "C" {
    int torchmain();
  }

  int main(){
    torchmain();
    return 0;
  }
#+end_src

** Script to compile
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./compile_g++.sh
  mkdir -pv -- './lib/' './tmp/'
  g++ \
      './src/main.cpp' -o './tmp/main.o' \
      -c -fPIC \
      '-I/usr/include/torch/csrc/api/include/' \
  ;

  g++ \
      './tmp.cpp' -o './tmp.exe' \
      './tmp/main.o' \
      -ltorch \
      -ltorch_cpu \
      -lc10 \
  ;
      # -laoti_custom_ops \
      # -lbackend_with_compiler \
      # -lgomp-98b21ff3 \
      # -ljitbackend_test \
      # -lnnapi_backend \
      # -lshm \
      # -ltorch_global_deps \
      # -ltorch_python \
      # -ltorchbind_test \
#+end_src

* Cargo.toml

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'Cargo.toml'
#+end_src

** Actual file
#+begin_src toml :tangle ./Cargo.toml
  [package]
  name = "burn_test"
  version = "0.1.0"
  edition = "2024"

  [build-dependencies]
  cc = { version = "1.2.46", features = ["jobserver", "parallel"] }
#+end_src

* Script to run the rust code

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'run.sh'
#+end_src

** Actual file
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./run.sh
  cd "$(dirname -- "${0}")"
  cargo run
#+end_src

* build.rs

** Add the file to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  G 'build.rs'
#+end_src

** Actual file
#+begin_src rust :tangle ./build.rs
  fn main() {
      let library_path = std::path::Path::new("/usr/include/torch/csrc/api/include/");

      cc::Build::new()
          .cpp(true)
          .file("src/main.cpp")
          .include(library_path)
          .compile("main");

      println!("cargo:rustc-link-arg=-ltorch");
      println!("cargo:rustc-link-arg=-lc10");
      println!("cargo:rustc-link-arg=-ltorch_cpu");
      // println!("cargo:rustc-link-arg=-Wl,--no-as-needed");
      // println!("cargo:rustc-link-arg=-laoti_custom_ops");
      // println!("cargo:rustc-link-arg=-lgomp-98b21ff3");
      // println!("cargo:rustc-link-arg=-lbackend_with_compiler");
      // println!("cargo:rustc-link-arg=-ljitbackend_test");
      // println!("cargo:rustc-link-arg=-lnnapi_backend");
      // println!("cargo:rustc-link-arg=-lshm");
      // println!("cargo:rustc-link-arg=-ltorch");
      // println!("cargo:rustc-link-arg=-ltorch_global_deps");
      // println!("cargo:rustc-link-arg=-ltorch_python");
      // println!("cargo:rustc-link-arg=-ltorchbind_test");
  }
#+end_src

* Main rust code

** Add files to git
#+begin_src sh :shebang #!/bin/sh :results output :tangle ./.git.sh
  S 'src,main.rs' 'src/main.rs'
#+end_src

** Actual code

*** Outputs from bindgen
#+begin_src rust :tangle ./src,main.rs
  unsafe extern "C" {
      pub fn torchmain();
  }
#+end_src

*** Actual rust parts
#+begin_src rust :tangle ./src,main.rs
  fn main() {
      println!("asd") ;
      unsafe {
      torchmain();
      }
  }
#+end_src

* COMMENT Work space
#+begin_src emacs-lisp :results silent
  (save-buffer)
  (org-babel-tangle)
  (async-shell-command "
      './.git.sh'
  " "log" "err")
#+end_src
